/**
 * Extractor code generator
 *
 * Generates reusable TypeScript extractor code from successful extractions.
 * Only generates code when validation passes.
 */

export interface ExtractorConfig {
  name: string;
  urlPattern: string;
  selectors: {
    container: string;
    fields: Record<string, string>;
  };
  dataTypes?: Record<string, 'string' | 'number' | 'boolean'>;
}

/**
 * Convert a name to a URL-safe slug
 */
export function slugify(name: string): string {
  return name
    .toLowerCase()
    .trim()
    .replace(/[^\w\s-]/g, '')
    .replace(/[\s_-]+/g, '-')
    .replace(/^-+|-+$/g, '');
}

/**
 * Convert a slug to a PascalCase interface name
 */
function toPascalCase(slug: string): string {
  return slug
    .split('-')
    .map(word => word.charAt(0).toUpperCase() + word.slice(1))
    .join('');
}

/**
 * Generate TypeScript extractor code
 */
export function generateExtractorCode(config: ExtractorConfig): string {
  const { name, urlPattern, selectors, dataTypes = {} } = config;
  const interfaceName = toPascalCase(slugify(name)) + 'Data';
  const fieldNames = Object.keys(selectors.fields);

  // Generate interface fields
  const interfaceFields = fieldNames
    .map(field => {
      const type = dataTypes[field] || 'string';
      return `  ${field}: ${type};`;
    })
    .join('\n');

  // Generate selector config
  const selectorFields = fieldNames
    .map(field => `    ${field}: '${escapeString(selectors.fields[field])}',`)
    .join('\n');

  // Generate extraction logic
  const extractionFields = fieldNames
    .map(field => {
      const selector = selectors.fields[field];
      return `      ${field}: await item.$eval('${escapeString(selector)}', el => el.textContent?.trim() ?? ''),`;
    })
    .join('\n');

  const date = new Date().toISOString().split('T')[0];

  return `/**
 * ${name} Extractor
 * Auto-generated by Manus on ${date}
 *
 * Usage:
 *   import { extract } from './${slugify(name)}';
 *   const data = await extract(page);
 */
import type { Page } from 'playwright';

export interface ${interfaceName} {
${interfaceFields}
}

export const config = {
  name: '${escapeString(name)}',
  urlPattern: ${formatUrlPattern(urlPattern)},
  selectors: {
    container: '${escapeString(selectors.container)}',
${selectorFields}
  },
};

/**
 * Extract data from the page
 */
export async function extract(page: Page): Promise<${interfaceName}[]> {
  const items = await page.$$(config.selectors.container);

  const data: ${interfaceName}[] = [];
  for (const item of items) {
    try {
      data.push({
${extractionFields}
      });
    } catch (error) {
      console.warn('Failed to extract item:', error);
    }
  }

  return data;
}

/**
 * Check if a URL matches this extractor's pattern
 */
export function matches(url: string): boolean {
  return config.urlPattern.test(url);
}

/**
 * Validate extracted data
 */
export function validate(data: ${interfaceName}[]): { valid: boolean; issues: string[] } {
  const issues: string[] = [];

  if (data.length === 0) {
    issues.push('No data extracted');
  }

  data.forEach((item, index) => {
    const emptyFields = Object.entries(item)
      .filter(([_, value]) => !value || String(value).trim() === '')
      .map(([key]) => key);

    if (emptyFields.length > 0) {
      issues.push(\`Row \${index + 1}: empty fields - \${emptyFields.join(', ')}\`);
    }
  });

  return {
    valid: issues.length === 0,
    issues,
  };
}
`;
}

/**
 * Escape string for use in generated code
 */
function escapeString(str: string): string {
  return str
    .replace(/\\/g, '\\\\')
    .replace(/'/g, "\\'")
    .replace(/\n/g, '\\n')
    .replace(/\r/g, '\\r')
    .replace(/\t/g, '\\t');
}

/**
 * Format URL pattern as regex literal or string
 */
function formatUrlPattern(pattern: string): string {
  // If it looks like a regex (contains regex special chars), format as regex
  if (/[.*+?^${}()|[\]\\]/.test(pattern)) {
    // Escape forward slashes for regex literal
    const escaped = pattern.replace(/\//g, '\\/');
    return `/${escaped}/`;
  }
  // Otherwise, create a regex that matches the domain
  const escaped = pattern.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
  return `/^https?:\\/\\/[^/]*${escaped}/i`;
}

/**
 * Generate an index file for all extractors in a directory
 */
export function generateExtractorIndex(extractors: string[]): string {
  if (extractors.length === 0) {
    return `/**
 * Extractors Index
 * Auto-generated - do not edit manually
 */

export const extractors: Record<string, unknown> = {};

export function getExtractor(name: string) {
  return extractors[name];
}

export function listExtractors(): string[] {
  return Object.keys(extractors);
}
`;
  }

  const imports = extractors
    .map((name, i) => `import * as extractor${i} from './${name}';`)
    .join('\n');

  const entries = extractors
    .map((name, i) => `  '${name}': extractor${i},`)
    .join('\n');

  return `/**
 * Extractors Index
 * Auto-generated - do not edit manually
 */

${imports}

export const extractors = {
${entries}
} as const;

export type ExtractorName = keyof typeof extractors;

export function getExtractor(name: ExtractorName) {
  return extractors[name];
}

export function listExtractors(): ExtractorName[] {
  return Object.keys(extractors) as ExtractorName[];
}
`;
}
